---
title: "Documentação doctr"
author: "Caio Lente"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Documentação doctr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

---
title: "Documentação doctr"
author: "Caio Lente"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Documentação doctr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> The doctor should be opaque to his patients and, like a mirror, should show them nothing but what is shown to him. - Sigmund Freud

`doctr` é um pacote de verificação de qualidade de dados para R. Através de algumas funções de uso simples ele consegue gerar análises exploratórias, rodar testes em variáveis e alertar para diferenças muito grandes entre duas entregas de uma mesma base.

## Instalação e leitura

```{r, echo = FALSE, message = FALSE}
library(dplyr)
library(stringr)
library(magrittr)
library(readr)
library(tibble)
library(doctr)
```

Para instalar o pacote, apenas rode `devtools::install_git("ctlente/doctr")`.

Agora que temos o pacote, podemos ler os dados que desejamos analisar. Não existe nenhuma recomendação muito específica para esse passo, mas precisamos que todos os missings sejam `NA` (não strings vazias). Isso já está implementado perfeitamente em `readr::read_csv` (ou `readr::read_delim` para arquivos separados por ponto-e-vírgula) e em `readxl::read_excel`.

Para esse tutorial usaremos a base `MASS::Cars93`, então nem precisamos nos preocupar em lê-la. Estas são algumas de suas colunas:

```{r, message = FALSE, echo = FALSE}
X <- tibble::tibble(
  dinheiro = c(
    1.23, 12.00, 1.5, 12.23, NA, NA
  ),
  contagem = c(
    1, 2, 3, 4, 5, 6
  ),
  quantidade = c(
    13.1415, 1234567.12, 1.111, 12, 13, NA
  ),
  continua = c(
    -123.1234, -2, 0, NA, NA, 12345
  ),
  categorica = c(
    "oi", "oi", "tchau", NA, "oi", "asdf"
  )
)
```

```{r, echo = FALSE}
X <- MASS::Cars93
knitr::kable(head(X[, 1:9]))
```

Nesse momento nos certificaríamos de que todas as colunas estão do jeito que esperamos (colunas numéricas como `numeric`s, colunas de texto como `character`s, colunas categóricas como `factor`s); este passo não deve durar muito mais que 5 minutos. Se estivermos satisfeitos com a tabela que acabamos de ler, podemos seguir em frente com a análise.

```{r}
# Transformar 'Model' em uma variável de texto
X$Model <- as.character(X$Model)
```

## Funções principais

### Examine

Esta função precisa de apenas uma entrada: `X` (a tabela a ser examinada). A partir de `X`, `examine` retornará uma lista com três tabelas contendo análises exploratórias, uma para as variáveis contínuas e uma para as variáveis categóricas.

Se rodarmos o código a seguir, obteremos as análises exploratórias em forma de tabelas comuns (aqui estou cortando os resultados, mas poderíamos usar `View` para visualizá-los por completo um a um).

```{r, message = FALSE}
# Gerar análise exploratória
exploratoria <- examine(X)

# Obter resultados da análise para variáveis numéricas
numericas <- report_num(exploratoria)
```

```{r, echo = FALSE, results = 'asis'}
knitr::kable(numericas[1:5, 1:15])
```

```{r, message = FALSE}
# Obter resultados da análise para variáveis de texto
textos <- report_chr(exploratoria)
```

```{r, echo = FALSE, results = 'asis'}
knitr::kable(textos[, 1:18])
```

```{r, message = FALSE}
# Obter resultados da análise para variáveis categóricas
categoricas <- report_fct(exploratoria)
```

```{r, echo = FALSE, results = 'asis'}
knitr::kable(head(categoricas))
```

Como todas as tabelas são muito grandes para serem mostradas, fica aqui um resumo do que cada uma de suas colunas representa:

| coluna | numéricas | textos | categóricas | descriçao |
|--|:--:|:--:|:--:|--|
| `name` | x | x | x | nome da variável de `X` que cada linha representa |
| `min`, `max` | x | x |  | valores/comprimentos mínimo e máximo da variável |
| `1%`, ..., `99%` | x | x |  | percentis dos valores/comprimentos da variável |
| `mean` | x | x |  | média dos valores/comprimentos da variável |
| `sd` | x | x |  | desvio padrão dos valores/comprimentos da variável |
| `na`, `val` | x | x |  | número de omissos e de não-omissos da variável |
| `neg`, `zero`, `pos` | x |  |  | número de valores positivos, zeros e negativos da variável |
| `unq` | x | x |  | número de valores/strings únicos da varável |
| `mdp` | x |  |  | número máximo de casas decimais dos valores da variável |
| `asc` |  | x |  | igual a 1 se o texto da variável é como ASCII, ou seja, não tem acentos |
| `ltr`, `num` |  | x |  | porcentagem do texto da variável que são letras e números |
| `data` |  |  | x | cada classe da variável |
| `cnt`, `frq` |  |  | x | contagem e frequência de cada classe da variável |

### Diagnose

A função `diagnose` recebe duas entradas: `X` (a tabela a ser diagnosticada) e `exams` (os exames a serem rodados em `X`).

Os `exams` têm uma formatação bastante específica que precisa ser atendida. Usando a função `guess_exams`, recebemos uma sugestão de exame pré-pronto para cada variável e espaço para customizarmos os parâmetros do mesmo.

```{r, message = FALSE}
exams <- guess_exams(X)
```

```{r, echo = FALSE, results = 'asis'}
knitr::kable(head(exams))
```

A coluna `cols` indica o nome da coluna de `X` em que o exame será rodado. `funs` por sua vez indica com qual tipo de variável estamos lidando, o que já carrega alguns exames pré-prontos para facilitar a vida do usuário; são esses tipos, do mais ao menos restritivo:

* `percentage`: devem ser valores entre 0 e 1
* `money`: devem ser valores positivos e ter no máximo duas casas decimais
* `count`: devem ser valores positivos e inteiros
* `quantity`: devem ser valores positivos
* `continuous`: devem ser valores numéricos
* `character`: devem ser textos

As outras colunas de `exams` são parâmetros customizáveis para os tipos especificados anteriormente:

| coluna | numéricas | textos | categóricas | descriçao |
|--|:--:|:--:|:--:|--|
| `max_na` | x | x | x | % máxima de NAs |
| `min_val`, `max_val` | x |  |  | valores mínimo e máximo |
| `max_dec_places` | x |  |  | percentis dos valores/comprimentos da variável |
| `min_unq`, `max_unq` |  | x | x | números mínimo e máximo de classes |
| `least_freq_cls` |  | x | x | % mínima do todo que uma classe pode representar |

Neste momento podemos mudar manualmente os testes e os parâmetros. No nosso caso podemos apenas trocar a `funs` das variáveis de preço para `money` e limitar o máximo de NAs em `Luggage.room` para 0%

```{r}
# Editar alguns testes manualmente
exams$funs[4:6] <- "money"
exams$max_na[24] <- 0
```

Depois que pensarmos em quais exames cada variável tem que passar, a única coisa que precisamos fazer é rodar `diagnose`. Essa função executará os exames em `X` e nos retornará uma lista de resultados que pode ser consultada com `issues`:

```{r}
resultados <- diagnose(X, exams)
issues(resultados)
```

Se quisermos consultar os problemas encontrados em colunas específicas, podemos usar `issues` com seu segundo argumento:

```{r}
# doctr::issues(resultados, 3)
# doctr::issues(resultados, "categorica")
```

Com isso temos um resumo compreensivo de em quais testes cada variável não passou. Ussamos essa informação para tratar a base ou para mudar nossas preconcepções sobre ela.

### Compare

A função `compare` seria o último passo no relatório de qualidade de dados e se torna útil quando temos que garantir que multiplas versões de uma base estão em condições semelhantes. Depois que já tivermos uma base em condições pristinas (seja usando ou não as funções descritas acima), podemos verificar se uma segunda entrega dessa base está no mesmo formato rodando `compare`.

Para propósitos de demonstração, testarei `compare` em cenários artificiais: comparando `X` consigo mesma, `X` com `exams` e `X` com uma fatia de si mesma. Ela retorna uma lista de resultados que pode ser consultada com `issues` exatamente como em `diagnose` (o nome dos parâmetros problemáticos seguem o mesmo formato que as colunas das tabelas retornadas por `examine`).

```{r}
# doctr::issues(doctr::compare(X, X))
# doctr::issues(doctr::compare(X, exams))
# doctr::issues(doctr::compare(X, X[1:5, ]))
```

Note como `continua` é a fonte da maior parte dos problemas porque o elemento cortado com sua última linha pesava bastante na maioria das métricas avaliadas.

## Paradigma

Como talvez já tenha ficado claro pelo nomes de suas funções, o `doctr` foi construído para emular o procedimento de um médico cuidando de um paciente. Essa metáfora facilita o entendimento do que cada parte do pacote faz. Deste modo podemos considerar que o `doctr` avalia a "saúde" (qualidade dos dados) de um "paciente" (base).

A primeira coisa que um médico faz ao se deparar com um novo paciente é examiná-lo; aqui ele gera uma ficha simples com dados sobre o paciente (peso, altura, etc.). Para isso temos a função `examine`, que gera a análise exploratória das colunas da base.

Depois disso o médico diagnostica seu paciente; sabendo os dados vitais da pessoa, ele a faz passar por exames mais específicos e, a partir dos resultados destes, consegue entender quais são os problemas que afligem-na. A função `diagnose` tem esse papel. Ela recebe uma base e os "exames" a serem rodados em suas colunas, e retorna se as colunas passaram nesses exames (e se não passaram, onde não passaram).

Depois de medicar o paciente (que nesse caso seria tratar a base até que ela passe nos exames), o médico avalia a sua evolução. A função `compare` cria perfis (uma "ficha clínica") para cada coluna de duas entregas de uma mesma base e retorna alertas quando um perfil está muito diferente do outro.
